diff --git a/ajax_facets.info b/ajax_facets.info
old mode 100755
new mode 100644
index 0197ee5..17027e3
--- a/ajax_facets.info
+++ b/ajax_facets.info
@@ -1,6 +1,7 @@
 name = Ajax facet filters
 description = Ajax facet filters.
 dependencies[] = facetapi (>=7.x-1.4)
+dependencies[] = multiselect
 dependencies[] = search_api
 dependencies[] = views
 package = Search Toolkit
@@ -12,4 +13,5 @@ files[] = plugins/facetapi/ajax_widget_checkboxes.inc
 files[] = plugins/facetapi/ajax_widget_select.inc
 files[] = plugins/facetapi/ajax_widget_links.inc
 files[] = plugins/facetapi/ajax_widget_ranges.inc
+files[] = plugins/facetapi/ajax_widget_multiselect.inc
 files[] = plugins/facetapi/empty_behavior_ajax_facets.inc
diff --git a/ajax_facets.module b/ajax_facets.module
index 259b912..c059a12 100755
--- a/ajax_facets.module
+++ b/ajax_facets.module
@@ -36,6 +36,9 @@ function ajax_facets_theme() {
     'ajax_facets_select' => [
       'render element' => 'element',
     ],
+    'ajax_facets_multiselect' => [
+      'render element' => 'element',
+    ],
   ];
 }
 
@@ -74,6 +77,13 @@ function ajax_facets_facetapi_widgets() {
         'query types' => ['term'],
       ],
     ],
+    'facetapi_ajax_multiselect' => [
+      'handler' => [
+        'label' => 'Ajax multiselect',
+        'class' => 'FacetapiAjaxMultiSelectWidget',
+        'query types' => ['term', 'date'],
+      ],
+    ],
   ];
 
   return $widgets;
@@ -441,4 +451,58 @@ function ajax_facets_form_select_options($element, $choices = NULL) {
     }
   }
   return $options;
-}
\ No newline at end of file
+}
+
+/**
+ * Fork of function theme_multiselect() provided by multiselect module.
+ * Implemented because theme_multiselect() renders a lot of markup we don't need.
+ * @TODO: Maybe we don't need multiselect module since we have to override so much of it anyways?
+ */
+function theme_ajax_facets_multiselect($variables) {
+  $element = $variables['element'];
+  element_set_attributes($element, array('id', 'name', 'size', 'multiple', 'default_value', 'required'));
+  _form_set_class($element, array('form-multiselect'));
+  $element['#field_name'] = $element['#name'];
+
+  return '<select' . drupal_attributes($element['#attributes']) . '>'  . ajax_facets_form_multiselect_options($element) .  '</select>';
+}
+
+/**
+ * Generates markup for multiselect options within a multiselect element.
+ */
+function ajax_facets_form_multiselect_options($element, $choices = NULL) {
+  if (!isset($choices)) {
+    $choices = $element['#options'];
+  }
+  // array_key_exists() accommodates the rare event where $element['#value'] is NULL.
+  // isset() fails in this situation.
+  $value_valid = isset($element['#value']) || array_key_exists('#value', $element);
+  $options = '';
+  foreach ($choices as $key => $choice) {
+    // @TODO: Not sure that $choice would ever be anything other than a string
+    // with current state of code.
+    if (is_array($choice)) {
+      $options .= '<optgroup label="' . check_plain($key) . '">';
+      $options .= form_select_options($element, $choice);
+      $options .= '</optgroup>';
+    }
+    elseif (is_object($choice)) {
+      $options .= form_select_options($element, $choice->option);
+    }
+    else {
+      $key = (string) $key;
+      // If option is currently active, set selected attribute.
+      if ($value_valid && isset($element['#value']) && in_array($key, $element['#value'])) {
+        $selected = ' selected="selected"';
+      }
+      else {
+        $selected = '';
+      }
+
+      $disabled = !empty($element['#disabled_items'][$key]) ? ' disabled' : '';
+
+      $options .= '<option value="' . check_plain($key) . '"' . $selected . $disabled . '>' . check_plain($choice) . '</option>';
+    }
+  }
+  return $options;
+}
diff --git a/misc/ajax_facets.js b/misc/ajax_facets.js
index 31b9a6f..03a4037 100755
--- a/misc/ajax_facets.js
+++ b/misc/ajax_facets.js
@@ -145,13 +145,25 @@
           if (settings.facetapi.facets[index].widget == 'facetapi_ajax_ranges') {
             $('#' + settings.facetapi.facets[index].id + '-wrapper div.slider-wrapper:not(.processed)').each(function () {
               var $sliderWrapper = $(this);
+              var $valueLabels = $sliderWrapper.parent().find('.range-slider__value-labels');
               $sliderWrapper.slider({
                 range: true,
                 min: parseFloat($sliderWrapper.data('min')),
                 max: parseFloat($sliderWrapper.data('max')),
                 values: [ parseFloat($sliderWrapper.data('min-val')), parseFloat($sliderWrapper.data('max-val')) ],
                 stop: function( event, ui ) {
-                  Drupal.ajax_facets.processSlider($sliderWrapper, ui.values[0], ui.values[1]);
+                  var min;
+                  var max;
+                  // If value labels are displayed, retrieve the taxonomy term ID from the label.
+                  if ($valueLabels.length) {
+                    min = $valueLabels.find('.value-labels__label[data-value="' + ui.values[0] + '"]').data('tid');
+                    max = $valueLabels.find('.value-labels__label[data-value="' + ui.values[1] + '"]').data('tid');
+                  }
+                  else {
+                    min = ui.values[0];
+                    max = ui.values[1];
+                  }
+                  Drupal.ajax_facets.processSlider($sliderWrapper, min, max, $valueLabels);
                 }
               }).addClass('processed');
 
@@ -165,7 +177,7 @@
                   if (isFinite(min) && isFinite(max) && min < max) {
                     $sliderWrapper.slider('values', 0, min);
                     $sliderWrapper.slider('values', 1, max);
-                    Drupal.ajax_facets.processSlider($sliderWrapper, min, max);
+                    Drupal.ajax_facets.processSlider($sliderWrapper, min, max, $valueLabels);
                   }
                 });
               });
@@ -173,6 +185,16 @@
             });
           }
 
+          // Multiselect.
+          if (settings.facetapi.facets[index].widget == 'facetapi_ajax_multiselect') {
+            $('#' + settings.facetapi.facets[index].id + '-wrapper select:not(.processed)').each(function () {
+              $(this).change(
+                [settings.facetapi.facets[index]],
+                Drupal.ajax_facets.processMultiselect
+              ).addClass('processed');
+            });
+          }
+
           if (null != settings.facetapi.facets[index].limit) {
             // Applies soft limit to the list.
             if (Drupal.facetapi) {
@@ -384,7 +406,7 @@
   /**
    * Callback for slide event for widget ranges.
    */
-  Drupal.ajax_facets.processSlider = function($sliderWrapper, min, max) {
+  Drupal.ajax_facets.processSlider = function($sliderWrapper, min, max, $valueLabels) {
     var $this = $(this),
       facetName = $sliderWrapper.data('facet-name');
     // Init history.
@@ -393,7 +415,79 @@
     if (Drupal.ajax_facets.queryState['f']) {
       // Exclude all values for this facet from query.
       Drupal.ajax_facets.excludeCurrentFacet(facetName);
-      Drupal.ajax_facets.queryState['f'][Drupal.ajax_facets.queryState['f'].length] = facetName + ':[' + min + ' TO ' + max + ']';
+
+      // If value labels exist we can retrieve the term IDs to
+      // add to query. Term IDs are not always incremental so querying
+      // as a true range query does not make sense.
+      // @TODO: It would be ideal if we could still only pass one arg in the form
+      // of field_name:[term_id TO term_id]. Perhaps this isn't possible because
+      // this is not a true range query.
+      if ($valueLabels.length) {
+        var rangeStarted = false;
+        $valueLabels.find('.value-labels__label').each(function() {
+          var termID = $(this).data('tid');
+          if (termID == min) {
+            rangeStarted = true;
+          }
+
+          if (rangeStarted) {
+            Drupal.ajax_facets.queryState['f'][Drupal.ajax_facets.queryState['f'].length] = facetName + ':' + termID;
+          }
+
+          if (termID == max) {
+            rangeStarted = false;
+          }
+        });
+      }
+      else {
+        Drupal.ajax_facets.queryState['f'][Drupal.ajax_facets.queryState['f'].length] = facetName + ':[' + min + ' TO ' + max + ']';
+      }
+    }
+
+    Drupal.ajax_facets.sendAjaxQuery({
+      pushStateNeeded: !Drupal.ajax_facets.ajax_facets_buttons,
+      searchResultsNeeded: !Drupal.ajax_facets.ajax_facets_buttons
+    }, $this);
+  };
+
+  /**
+   * Callback for onClick event for widget multiselect.
+   */
+  Drupal.ajax_facets.processMultiselect = function (event) {
+    var $this = $(this),
+      facetName = $this.data('facet-name');
+
+    // Init history.
+    Drupal.ajax_facets.initHistoryState($this);
+
+    // Get all selected options and deselected options.
+    var selectedOptions = [];
+    var deselectedOptions = [];
+    for (var optionIndex in $this[0]) {
+      if (isNaN(optionIndex)) {
+        continue;
+      }
+      var $optionElement = $($this[0][optionIndex]);
+      var optionValue = $optionElement.val();
+      var nameValue = facetName + ':' + optionValue; // $.data can round decimal values like 4.0 to 4, avoid it.
+      if ($optionElement.is(':selected')) {
+        selectedOptions[optionValue] = nameValue;
+      }
+      else {
+        deselectedOptions[optionValue] = nameValue;
+      }
+    }
+
+    // Remove params for deselected options from queryState.
+    Drupal.ajax_facets.queryState['f'] = Drupal.ajax_facets.queryState['f'].filter(function(element) {
+      return deselectedOptions.indexOf(element) < 0;
+    });
+
+    // Add params for selected options to queryState.
+    for (var optionValue in selectedOptions) {
+      if ($.inArray(selectedOptions[optionValue], Drupal.ajax_facets.queryState['f']) == -1) {
+        Drupal.ajax_facets.queryState['f'].push(selectedOptions[optionValue]);
+      }
     }
 
     Drupal.ajax_facets.sendAjaxQuery({
@@ -796,4 +890,4 @@
       }
     };
   }
-})(jQuery);
\ No newline at end of file
+})(jQuery);
diff --git a/plugins/facetapi/ajax_widget.inc b/plugins/facetapi/ajax_widget.inc
index 89207c2..0f49e35 100755
--- a/plugins/facetapi/ajax_widget.inc
+++ b/plugins/facetapi/ajax_widget.inc
@@ -91,6 +91,7 @@ class FacetapiAjaxWidget extends FacetapiWidgetCheckboxLinks {
 
       case 'facetapi_ajax_links':
       case 'facetapi_ajax_checkboxes':
+      case 'facetapi_ajax_multiselect':
         return str_replace('_', '-', $this->id) . '-' . str_replace($to_replace, '-', $this->key . '-' . drupal_strtolower($value));
         break;
     }
diff --git a/plugins/facetapi/ajax_widget_multiselect.inc b/plugins/facetapi/ajax_widget_multiselect.inc
new file mode 100644
index 0000000..6770499
--- /dev/null
+++ b/plugins/facetapi/ajax_widget_multiselect.inc
@@ -0,0 +1,141 @@
+<?php
+
+/**
+ * @file
+ * Defines a plugin for a multiselect facet API widget.
+ */
+
+/**
+ * Widget that renders facets as a multiselect element.
+ */
+class FacetapiAjaxMultiSelectWidget extends FacetapiAjaxWidget {
+
+  /**
+   * Overrides FacetapiWidget::getDefaultSettings().
+   */
+  function getDefaultSettings() {
+    return [
+      "show_reset_link" => 0,
+    ];
+  }
+
+  /**
+   * Transforms the render array for use with theme_item_list().
+   *
+   * The recursion allows this function to act on the various levels of a
+   * hierarchical data set.
+   *
+   * @param array $build
+   *   The items in the facet's render array being transformed.
+   *
+   * @return array
+   *   The "items" parameter for theme_item_list().
+   */
+  function buildListItems($build, $level = 0) {
+    $settings = $this->settings->settings;
+
+    // Builds rows.
+    $items = [
+      '#disabled_items' => [],
+    ];
+
+    // Note that for a multiselect element it doesn't make sense to
+    // have a default value so we're not setting one here.
+
+    $prefix = str_repeat('-', $level);
+    $level++;
+
+    $active_items = [];
+    $items['active_items'] = [];
+    $have_active = FALSE;
+    foreach ($build as $value => $item) {
+      // Respect current selection.
+      if (!empty($item['#active'])) {
+        $have_active = TRUE;
+        $active_items[] = $this->key . ':' . $item['#markup'];
+        $items['active_items'][] = $item['#indexed_value'];
+      }
+
+      $items['options'][$item['#indexed_value']] = $prefix . $item['#markup'];
+
+      // Mark as disabled if count is 0.
+      if ($item['#count'] == 0) {
+        $items['#disabled_items'][$item['#indexed_value']] = TRUE;
+      }
+
+      // Show/hide counts according to the settings.
+      if (!empty($this->settings->settings['display_count'])) {
+        $items['options'][$item['#indexed_value']] .= ' ' . theme('facetapi_count',(['count' => $item['#count']]));
+      }
+
+      // @TODO: Not sure that a multiselect can have children.
+      // Copied from FacetapiAjaxSelectWidget::BuildListItems().
+      if (!empty($item['#item_children'])) {
+        $childrens = $this->buildListItems($item['#item_children'], $level);
+        if (!empty($childrens['active_value'])) {
+          $items['active_value'] = $childrens['active_value'];
+        }
+        $items['options'] = $items['options'] + $childrens['options'];
+      }
+    }
+
+    $this->jsSettings['haveActiveSelection'] = $this->settings->settings['have_active_selection'] = $have_active;
+    sort($active_items);
+    $this->jsSettings['activeItems'] = $active_items;
+    // Generate reset path on server side to make possible to use aliases.
+    if ($have_active) {
+      $this->jsSettings['resetPath'] = ajax_facets_facet_build_reset_path($this->facet->getFacet(), $this->facet->getAdapter());
+    }
+    return $items;
+  }
+
+  /**
+   * Implements FacetapiWidget::execute().
+   *
+   * Transforms the render array into something that can be themed by
+   * theme_item_list().
+   *
+   * @see FacetapiWidgetLinks::setThemeHooks()
+   * @see FacetapiWidgetLinks::buildListItems()
+   */
+  public function execute() {
+    $element = &$this->build[$this->facet['field alias']];
+    $items = $this->buildListItems($element);
+
+    // If name is empty - use label.
+    if (empty($items['name'])) {
+      $facet = $this->facet->getFacet();
+      $items['name'] = $facet['label'];
+    }
+
+    $select = [
+      '#type' => 'multiselect',
+      '#title' => $this->build['#title'],
+      '#options' => $items['options'],
+      '#name' => rawurlencode($this->settings->facet),
+      '#attributes' => [
+        'data-facet-name' => rawurlencode($this->settings->facet),
+        'data-raw-facet-name' => $this->settings->facet,
+      ],
+      '#theme' => 'ajax_facets_multiselect',
+      '#disabled_items' => $items['#disabled_items'],
+      '#value' => $items['active_items'],
+    ];
+
+    if (!empty($items['active_value'])) {
+      $select['#value'] = $items['active_value'];
+    }
+
+    // We cannot use drupal_html_id to save the same id for each facet.
+    $wrapper_id = $this->build['#attributes']['id'] . '-wrapper';
+
+    $element = [
+      '#markup' => '<div id="' . $wrapper_id . '">'
+        . $this->getResetLink()
+        . render($select)
+        . '</div>'
+    ];
+
+    ajax_facets_add_ajax_js($this->facet);
+  }
+}
diff --git a/plugins/facetapi/ajax_widget_ranges.inc b/plugins/facetapi/ajax_widget_ranges.inc
index d2679e4..baef20e 100755
--- a/plugins/facetapi/ajax_widget_ranges.inc
+++ b/plugins/facetapi/ajax_widget_ranges.inc
@@ -70,60 +70,187 @@ class FacetapiAjaxWidgetRanges extends FacetapiAjaxWidget {
       'class' => ['slider-wrapper'],
     ];
 
-    // Get min and max values.
-    $raw_values = array_keys($element);
-    $raw_values = array_filter($raw_values, 'is_numeric');
+    $raw_values = [];
+    $terms = null;
+    // @TODO: This should be an admin option
+    // but only allowed if the field is a taxonomy term reference.
+    $display_value_labels = true;
+    $global_min = null;
+    $global_max = null;
+    $active_min_tid = null;
+    $active_max_tid = null;
+    $active_min_term_name = null;
+    $active_max_term_name = null;
 
-    // Check that we have values for the facet widget.
-    if (!empty($raw_values)) {
-      $global_min = min($raw_values);
-      $global_max = max($raw_values);
+    // If this is a taxonomy term reference field The order of the options
+    // should be determined by the order of the taxonomy terms
+    // at /admin/structure/taxonomy/*.
+    if ($this->build['#facet']['field type'] == 'taxonomy_term') {
+      $field = field_info_field($this->build['#facet']['field']);
+      $vocab_name = $field['settings']['allowed_values'][0]['vocabulary'];
+      $vocabulary = taxonomy_vocabulary_machine_name_load($vocab_name);
+      $terms = entity_load('taxonomy_term', FALSE, array('vid' => $vocabulary->vid));
+
+      // Order terms by weight.
+      usort($terms, function ($term1, $term2) {
+        return $term1->weight > $term2->weight;
+      });
+      $terms = array_values($terms);
+
+      if (!empty($terms)) {
+        foreach ($terms as $term) {
+          $raw_values[] = $term->tid;
+        }
+      }
 
+      // Set global min and max based on first and last term.
+      // However, jQuery UI Slider requires values to be incremental,
+      // which term IDs are not usually. To get around this we set
+      // global min and max to incremental integers based on the total number of terms.
+      if (!empty($raw_values)) {
+        $global_min = 1;
+        $global_max = count($raw_values);
+
+        // Pass the global min and max term IDs to JS.
+        $slider_attrs['data-min-tid'] = $raw_values[0];
+        $slider_attrs['data-max-tid'] = end($raw_values);
+      }
+    }
+    // If field is not taxonomy term reference then we can determine
+    // global min and max based on field value.
+    else {
+      $raw_values = array_keys($element);
+      $raw_values = array_filter($raw_values, 'is_numeric');
+
+      // Check that we have values for the facet widget.
+      if (!empty($raw_values)) {
+        $global_min = min($raw_values);
+        $global_max = max($raw_values);
+      }
+    }
+
+    // Set global min and max values.
+    if (!empty($global_min)) {
       $slider_attrs['data-min'] = $global_min;
       $slider_attrs['data-max'] = $global_max;
+    }
 
+    // Check that we have values for the facet widget.
+    if (!empty($raw_values)) {
       // Get selected min and max for active value.
       if (!empty($items['active_value'])) {
-        $values = explode(' TO ', $items['active_value']);
-        $slider_attrs['data-min-val'] = preg_replace('/[^0-9\.]/', '', $values[0]);
-        $slider_attrs['data-max-val'] = preg_replace('/[^0-9\.]/', '', $values[1]);
+        // If field is taxonomy term reference.
+        if (!empty($terms)) {
+          // Retrieve all args for this facet from URL.
+          $selected_values = [];
+          if (!empty($_GET['f'])) {
+            foreach($_GET['f'] as $arg) {
+              if (strpos($arg, $field['field_name']) !== false) {
+                $exploded_value = explode($field['field_name'] . ':', $arg);
+                $selected_values[] = $exploded_value[1];
+              }
+            }
+          }
+          // Find min and max based on ordered list of term IDs.
+          $active_min_tid = $selected_values[0];
+          $active_max_tid = end($selected_values);
+          $active_min = array_search($active_min_tid, $raw_values) + 1;
+          $active_max = array_search($active_max_tid, $raw_values) + 1;
+
+          // Render the active min and max term IDs as HTML data attributes for clarity.
+          $slider_attrs['data-min-val-tid'] = $active_min_tid;
+          $slider_attrs['data-max-val-tid'] = $active_max_tid;
+
+          // Record active min and max term names to use as value of input fields.
+          foreach($terms as $term) {
+            if ($term->tid == $active_min_tid) {
+              $active_min_term_name = $term->name;
+            }
+            if ($term->tid == $active_max_tid) {
+              $active_max_term_name = $term->name;
+            }
+          }
+        }
+        else {
+          $values = explode(' TO ', $items['active_value']);
+          $active_min = preg_replace('/[^0-9\.]/', '', $values[0]);
+          $active_max = preg_replace('/[^0-9\.]/', '', $values[1]);
+        }
       }
-      // Get selected min and max by default.
+      // Get selected min and max to defaults.
       else {
-        $slider_attrs['data-min-val'] = $global_min;
-        $slider_attrs['data-max-val'] = $global_max;
+        $active_min = $global_min;
+        $active_max = $global_max;
       }
 
+      $slider_attrs['data-min-val'] = $active_min;
+      $slider_attrs['data-max-val'] = $active_max;
+
       // @todo move it into the other place?
       drupal_add_library('system', 'ui.slider');
 
-      $min_input = theme(
+      // Construct markup for min max input fields.
+      $input_field_markup = '<div class="range-slider__inputs">';
+
+      if (!empty($active_min_term_name)) {
+        $min_input_value = $active_min_term_name;
+      }
+      else {
+        $min_input_markup = $slider_attrs['data-min-val'];
+      }
+
+      $input_field_markup .= theme(
         'ajax_facets_ranges_input',
         [
           'title' => t('From:'),
           'attributes' => ['class' => 'ajax-facets-slider-amount-min'],
-          'value' => $slider_attrs['data-min-val'],
+          'value' => $min_input_value,
         ]
       );
 
-      $max_input = theme(
+      if (!empty($active_max_term_name)) {
+        $max_input_value = $active_max_term_name;
+      }
+      else {
+        $max_input_markup = $slider_attrs['data-max-val'];
+      }
+
+      $input_field_markup .= theme(
         'ajax_facets_ranges_input',
         [
           'title' => t('To:'),
           'attributes' => ['class' => 'ajax-facets-slider-amount-max'],
-          'value' => $slider_attrs['data-max-val'],
+          'value' => $max_input_value,
         ]
       );
 
+      $input_field_markup .= '</div>';
+
+      // If this is a taxonomy term reference field,
+      // construct markup to display taxonomy term names
+      // horizontally along range slider.
+      $values_markup = '';
+      if (!empty($terms)) {
+        $values_markup = '<div class="range-slider__value-labels">';
+
+        foreach ($terms as $key => $term) {
+          $value = $key + 1;
+          $values_markup .= '<span class="value-labels__label" data-tid="' . $term->tid . '" data-value="' . $value . '"><span class="label__text">' . $term->name . '</span></span>';
+        }
+
+        $values_markup .= '</div>';
+      }
+
       // We cannot use drupal_html_id to save the same id for each facet.
       $wrapper_id = $this->build['#attributes']['id'] . '-wrapper';
 
       $element = [
-        '#markup' => '<div id="' . $wrapper_id . '">'
+        '#markup' => '<div id="' . $wrapper_id . '" class="ajax-facets--range-slider">'
+          . '<label>' . $this->build['#title'] . '</label>'
           . $this->getResetLink()
           . '<div class="ajax-facets-controls-wrapper">'
-          . $min_input
-          . $max_input
+          . $input_field_markup
+          . $values_markup
           . '<div ' . drupal_attributes($slider_attrs) . '></div>'
           . '</div>'
           . '</div>'
